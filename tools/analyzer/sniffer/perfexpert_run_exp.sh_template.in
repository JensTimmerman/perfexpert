# BEGIN OF PARSING/CHECKING ARGUMENTS
#
#         12345678901234567890123456789012345678901234567890123456789012345678901234567890
showHelp() {
    echo "Usage: analyzer_run_exp [-ngh] [-t DIR] [-s FILE] [-o FILE] [-b FILE] [-a FILE] program_executable"
    echo "                        [program_arguments]"
    echo
    echo "  -s --structure FILE  Use FILE as program structure (generated by hpcstruct)"
    echo "  -o --output FILE     Save measurements to FILE"
    echo "  -n --no-debug        Do not switch to debug mode if program fails to execute"
    echo "                       with Analyzer"
    echo "  -g --left-garbage    Do not remove the temporary directory"
    echo "  -t --tempdir DIR     Use DIR as temporary directory. The content in this"
    echo "                       directory will be erased before using it (!! WARNING !!)"
    echo "  -b --before FILE     Execute FILE before each run of the application"
    echo "  -a --after FILE      Execute FILE after each run of the application"
    echo "  -h --help            Show this message"
}

for arg; do
    delim=""
    case "$arg" in
        # translate GNU long options to short options
        --structure)    args="${args}-s ";;
        --output)       args="${args}-o ";;
        --no-debug)     args="${args}-n ";;
        --help)         args="${args}-h ";;
        --left-garbage) args="${args}-g ";;
        --tempdir)      argd="${args}-t ";;
        --before)       argd="${args}-b ";;
        --after)        argd="${args}-a ";;

        # pass through anything else
        *) [[ "${arg:0:1}" == "-" ]] || delim="\""
        args="${args}${delim}${arg}${delim} ";;
    esac
done

# Reset the positional parameters to the short options
eval set -- $args

debug=true
structure=""
structureSet=false
left_garbage=false

pre_exec=""
post_exec=""

# Generate output filename
if [ "x${JOB_NAME}" == "x" ]; then
    output_filename="experiment.xml"
else
    output_filename="experiment-${JOB_NAME}.o${JOB_ID}.xml"
fi

while getopts ":s:o:t:nhgb:a:" option 2>/dev/null; do
    case $option in
        s)
        structure="${OPTARG[@]}"
        structureSet=true
        ;;

        o)
        output_filename="${OPTARG[@]}"
        ;;

        n)
        debug=false
        ;;

        g)
        left_garbage=true
        ;;

        t)
        tempdir="${OPTARG[@]}"
        ;;

        b)
        pre_exec="${OPTARG[@]}"
        ;;

        a)
        post_exec="${OPTARG[@]}"
        ;;

        h)
        showHelp
        exit 1
        ;;

        *)
        echo "[analyzer] Error: unrecognized option: ${OPTARG}"
        exit 1
        ;;
    esac
done
shift $(($OPTIND - 1))

command=${*}

# Sanity checks
if [ ${#} -lt 1 ]; then
    showHelp
    exit 1
fi

if [ "x${structureSet}" == "xtrue" ]; then
    hpcstruct_file="${structure}"
    if [ ! -f "${hpcstruct_file}" ]; then
        echo "[analyzer] Error: could not find hpcstruct file: ${hpcstruct_file}"
        exit 1
    fi
    echo "[analyzer] Using existing structure file: ${hpcstruct_file}"
fi

program_name="${1}"

# Ignore taskset, numactl, ibrun
for arg in $@
do
	# Get just the filename
	arg_string=`basename "${arg}" 2>/dev/null`

	# Guard against possibly empty string being encountered here
	if [ -n "${arg_string}" ]
	then
		# Check if the argument is not taskset, not numactl, is a file and is executable
		if [ "${arg_string}" != "taskset" -a "${arg_string}" != "numactl" -a -f "${arg_string}" -a -x "${arg_string}" ]
		then
			program_name="${arg_string}"
			break
		fi
	fi
done

cmdline=${*}

# If it is in ${PATH}, form the absolute path
fullPath=`which ${program_name} 2>/dev/null`
if [ ${?} -ne 0 ]; then
    # Try checking if the file is in the current directory
    if [ -x "./${program_name}" ]; then
        fullPath="./${program_name}"
    else
        # Instead of raising an error, use the program name as it is
        fullPath="${program_name}"
    fi
fi

# Set the original variable back
program_name="${fullPath}"

if [ ! -f "${program_name}" ]; then
    echo "[analyzer] Error: could not run file: ${program_name}"
    exit 1
fi

# Check if we have valid pre and post exec scripts
if [ -n "$pre_exec" ]
then
    fullPath=`which ${pre_exec} 2>/dev/null`

    # Check if we have a valid executable file
    if [ ${?} -ne 0 ]; then
        # Try checking if the file is in the current directory
        if [ -x "./${pre_exec}" ]; then
            fullPath="./${pre_exec}"
        else
            # Instead of raising an error, use the program name as it is
            fullPath="${pre_exec}"
        fi
    fi

    if [ -x "$fullPath" ]; then
        pre_exec="$fullPath"
    else
        echo "[analyzer] Error: Could not find a valid executable pre-execution file: $pre_exec"
	exit 1
    fi
fi

if [ -n "$post_exec" ]
then
    fullPath=`which ${post_exec} 2>/dev/null`

    # Check if we have a valid executable file
    if [ ${?} -ne 0 ]; then
        # Try checking if the file is in the current directory
        if [ -x "./${post_exec}" ]; then
            fullPath="./${post_exec}"
        else
            # Instead of raising an error, use the program name as it is
            fullPath="${post_exec}"
        fi
    fi

    if [ -x "$fullPath" ]; then
        post_exec="$fullPath"
    else
        echo "[analyzer] Error: Could not find a valid executable post-execution file: $post_exec"
	exit 1
    fi
fi
#
# END OF PARSING/CHECKING ARGUMENTS

# Put everything into a temporary directory
if [ "x${tempdir}" == "x" ]; then
    tempdir=`mktemp -d .analyzer-temp-XXXXXXX`
else
    mkdir -p "${tempdir}"
fi

# If for some reason tempdir was not set, set it to a default
if [ "x${tempdir}" == "x" ]; then
        tempdir=".analyzer-temp"
        mkdir -p "${tempdir}"
fi

# Just to be sure, we remove any files which might previously exist
if [ "x${tempdir}" == "x." ]; then
    echo "[analyzer] Sorry, we can't use the current directory to store temporary files."
fi

if [ "x${tempdir}" == "x./" ]; then
    echo "[analyzer] Sorry, we can't use the current directory to store temporary files."
fi

# I don't like the idea of erasing with 'rm -rf *', let's try do something different
#rm -rf ${tempdir}/*
rm -rf ${tempdir}/hpcstruct
rm -rf ${tempdir}/measurements
rm -rf ${tempdir}/database
rm -rf ${tempdir}/hpcprof.output

# HPCTOOLKIT: STRUCT FILE (HPCSTRUCT)
#
# Check if we received the HPCStruct file as a parameter
if [ "x${hpcstruct_file}" != "x" ]; then
    # If yes, use it
    cp "${hpcstruct_file}" "${tempdir}/hpcstruct"
else
    # Else generate it
    echo -n "[analyzer] Generating program structure using hpcstruct..."
    @HPCSTRUCT_PROGRAM@ --output "${tempdir}/hpcstruct" "${program_name}"
    echo " done!"
fi

# If anything goes bad, here is where we dump the information
debug_file="analyzer_debug.out"

# HPCTOOLKIT: MEASURING PHASE (HPCRUN)
#
# Run experiments with different configurations
count=$((${#experiment[@]}-1))
for index in $(seq 0 $((${#experiment[@]}-1))); do
    echo "[analyzer] Program execution #$((${index}+1)) of ${#experiment[@]}"

    if [ -n "$pre_exec" ]; then
        "$pre_exec" $index $count
    fi

    cmd="@HPCRUN_PROGRAM@ ${experiment[${index}]} --output ${tempdir}/measurements ${cmdline}"
    eval ${cmd}

    if [ -n "$post_exec" ]; then
        "$post_exec" $index $count
    fi

    if [ ${debug} == "true" -a ${?} != "0" ]; then
        echo "[analyzer] Looks like the previous command failed to terminate cleanly, switching to debug mode..."

        rm -f "${debug_file}"

        echo "[analyzer] Collecting information about OS and processor..."

        uname -a >> "${debug_file}" 2>&1
        echo >> "${debug_file}"
        cat /proc/cpuinfo >> "${debug_file}" 2>&1

        echo -e "[analyzer] Command: ${cmd}\n" >> "${debug_file}"
        echo -e "[analyzer] run\nbt\nthread apply all bt\nquit" > "${tempdir}/stacktraces.cmd"

        if [ -n "$pre_exec" ]; then
            echo "[analyzer] Running pre-execution script: $pre_exec $index $count"
            "$pre_exec" $index $count
        fi

        echo "[analyzer] Collecting stack trace..."
        dbg_cmd="gdb --command=${tempdir}/stacktraces.cmd --args /bin/sh ${cmd} 2>> ${debug_file} 1>/dev/null"
        eval ${dbg_cmd}

        if [ -n "$post_exec" ]; then
            echo "[analyzer] Running post-execution script: $post_exec $index $count"
            "$post_exec" $index $count
        fi

        if [ -n "$pre_exec" ]; then
            echo "[analyzer] Running pre-execution script: $pre_exec $index $count"
            "$pre_exec" $index $count
        fi

        echo "[analyzer] Collecting debug information from hpcrun monitor..."
        dbg_cmd="@HPCRUN_PROGRAM@ --monitor-debug ${experiment[${index}]} --output ${tempdir}/measurements ${cmdline} 2>> ${debug_file} 1>/dev/null"
        echo -e "\n[analyzer] Command: ${dbg_cmd}\n" >> "${debug_file}"
        eval ${dbg_cmd}

        echo "[analyzer] Debug information collected in ./${debug_file}, please send this file to the Analyzer group for review. Thanks!"

        if [ -n "$post_exec" ]; then
            echo "[analyzer] Running post-execution script: $post_exec $index $count"
            "$post_exec" $index $count
        fi

        # Clean up
        rm -rf core
        if [ "x${left_garbage}" == "xfalse" ]; then
            rm -rf "${tempdir}"
        else
            echo "[analyzer] Temporary files are available on '${tempdir}' directory"
        fi
        exit 1
    fi
done

# HPCTOOLKIT: SUMMARIZING RESULTS (HPCPROF)
#
echo -n "[analyzer] Finished all measurements, summarizing the results..."
@HPCPROF_PROGRAM@ --force-metric --metric=thread --struct "${tempdir}/hpcstruct" --output "${tempdir}/database" "${tempdir}/measurements" &> "${tempdir}/hpcprof.output"
returnCode=${?}

if [ "x${returnCode}" != "x0" ]; then
    echo "error!"
    cat "${tempdir}/hpcprof.output"

    # Clean up
    if [ "x${left_garbage}" == "xfalse" ]; then
        rm -rf "${tempdir}"
    else
        echo "[analyzer] Temporary files are available on '${tempdir}' directory"
    fi
else
    echo " done!"

    # Get the final experiment.xml here
    cp "${tempdir}/database/experiment.xml" "./${output_filename}"

    # Clean up
    if [ "x${left_garbage}" == "xfalse" ]; then
        rm -rf "${tempdir}"
    else
        echo "[analyzer] Temporary files are available on '${tempdir}' directory"
    fi

    echo "[analyzer] Run the following command to analyze the measurement data:"
    echo "[analyzer] analyzer <threshold-between-0-and-1> ./${output_filename}"
fi